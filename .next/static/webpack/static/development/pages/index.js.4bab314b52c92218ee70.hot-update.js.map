{"version":3,"file":"static/webpack/static\\development\\pages\\index.js.4bab314b52c92218ee70.hot-update.js","sources":["webpack:///./core/ContractManager.js"],"sourcesContent":["import web3 from '../ethereum/web3';\r\nimport compiledContract from '../ethereum/build/EtherChat.json';\r\nimport TransactionsManager from './TransactionManager';\r\nimport appDispatcher from './AppDispatcher';\r\nimport Config from '../support/Config';\r\nimport Constant from '../support/Constant';\r\nimport utils from '../support/Utils';\r\nimport crypto from 'crypto';\r\n\r\n/**\r\n * Responsible for interacting with the Ethereum smart contract\r\n */\r\n\r\nexport class ContractManager {\r\n    constructor(accountManager, storageManager) {\r\n        this.getContract();\r\n        this.accountManager = accountManager;\r\n        this.storageManager = storageManager;\r\n        this.transactionManager = new TransactionsManager(accountManager);\r\n    }\r\n\r\n    // Create a web3 contract object that represent the ethereum smart contract\r\n    getContract = async () => {\r\n        this.contract = await new web3.eth.Contract(JSON.parse(compiledContract.interface), \r\n                Config.ENV.ContractAddress);\r\n        appDispatcher.dispatch({\r\n            action: Constant.EVENT.CONTRACT_READY\r\n        })\r\n    }\r\n\r\n    // Get current account profile from EtherChat contract's storage\r\n    getProfile = async (address) => {\r\n        var result = await this.contract.methods.members(this.accountManager.getAddress()).call();\r\n        var profile = {};\r\n        if (result.isMember == 1) {\r\n            profile.isJoined = true;\r\n            profile.avatarUrl = utils.hexStringToAsciiString(result.avatarUrl);\r\n            profile.name = utils.hexStringToAsciiString(result.name);\r\n\r\n            this.storageManager.setJoinedStatus(true);\r\n            this.storageManager.setName(this.name);\r\n            this.storageManager.setAvatarUrl(this.avatarUrl);\r\n            \r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.ACCOUNT_INFO_UPDATED,\r\n                profile: profile\r\n            })\r\n        }\r\n        return profile;\r\n    }\r\n\r\n    getMemberInfo = async (address, relationship) => {\r\n        var memberInfo = await this.contract.methods.members(address).call();\r\n        if (memberInfo.isMember) {\r\n            var publicKey = '04' + memberInfo.publicKeyLeft.substr(2) + memberInfo.publicKeyRight.substr(2);\r\n            var name = utils.hexStringToAsciiString(memberInfo.name);\r\n            var avatarUrl = utils.hexStringToAsciiString(memberInfo.avatarUrl);\r\n            this.storageManager.updateContact(address, publicKey, name, avatarUrl, relationship);\r\n        }\r\n    }\r\n\r\n    getPastEvents = async (eventName, filters) => {\r\n        return await this.contract.getPastEvents(eventName, filters);\r\n    }\r\n\r\n    joinContract = async(publicKeyBuffer, callback) => {\r\n        var publicKeyLeft = '0x' + publicKeyBuffer.toString('hex', 0, 32);\r\n        var publicKeyRight = '0x' + publicKeyBuffer.toString('hex', 32, 64);\r\n\r\n        this.transactionManager.executeMethod(this.contract.methods.join(publicKeyLeft, publicKeyRight))\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_REJECTED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_REJECTED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n    // joinContract = async (publicKeyBuffer, callback) => {\r\n\r\n    addContact = async (address, callback) => {\r\n        console.log(address);\r\n\r\n        var method = this.contract.methods.addContact(address);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    acceptContactRequest = async (address, callback) => {\r\n        var method = this.contract.methods.acceptContactRequest(address);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    updateProfile = async (name, avatarUrl, callback) => {\r\n        var nameHex = '0x' + Buffer.from(name, 'ascii').toString('hex');\r\n        var avatarUrlHex = '0x' + Buffer.from(avatarUrl, 'ascii').toString('hex');\r\n        var method = this.contract.methods.updateProfile(nameHex, avatarUrlHex);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    // A message will be encrypted locally before sending to the smart contract\r\n    sendMessage = async (toAddress, publicKey, message) => {\r\n        var publicKeyBuffer = Buffer.from(publicKey, 'hex');\r\n        var encryptedRaw = utils.encrypt(message, this.accountManager.computeSecret(publicKeyBuffer));\r\n        var encryptedMessage = '0x' + encryptedRaw.toString('hex');\r\n        var method = this.contract.methods.sendMessage(toAddress, encryptedMessage, utils.getEncryptAlgorithmInHex());\r\n\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                this.storageManager.addMyLocalMessage(encryptedMessage, toAddress, utils.getEncryptAlgorithm(), txHash);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            })\r\n            .on(Constant.EVENT.ON_REJECTED, (data) => {\r\n                // do nothing\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt, ) => {\r\n                this.storageManager.updateLocalMessage(toAddress, receipt.transactionHash, Constant.SENT_STATUS.SUCCESS);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                this.storageManager.updateLocalMessage(toAddress, txHash, Constant.SENT_STATUS.FAILED);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            });\r\n    }\r\n}\r\n\r\nexport default ContractManager;"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AADA;AACA;AADA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAEA;AACA;AADA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AATA;AAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAjBA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAlBA;AAqCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAtCA;AA+CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAhDA;AAmDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AApDA;AA4EA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA7EA;AAiGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAlGA;AAoHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AArHA;AA0IA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AAAA;AACA;AACA;AAFA;AAIA;AACA;AA/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AA1IA;AACA;AACA;AACA;AACA;AANA;AA6KA;;;;;A","sourceRoot":""}