{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { sha256 } from 'ethereumjs-util';\nimport Wallet from 'ethereumjs-wallet';\nimport crypto from 'crypto';\nimport web3 from '../ethereum/web3';\nimport utils from '../support/Utils';\nimport EventHandler from './EventHandler';\nimport appDispatcher from '../core/AppDispatcher';\nimport TransactionManager from './TransactionManager';\nimport Constant from '../support/Constant';\nimport Config from '../support/Config';\n\nclass AccountManager {\n  constructor(storageManager) {\n    _defineProperty(this, \"loadInfoFromstorageManager\", () => {\n      this.balance = this.storageManager.getBalance();\n      this.name = this.storageManager.getName();\n      this.avatarUrl = this.storageManager.getAvatarUrl();\n      this.isJoined = this.storageManager.getJoinedStatus();\n      this.askForTransactionApproval = this.storageManager.getAskForTransactionApproval();\n    });\n\n    _defineProperty(this, \"setProfile\", (name, avatarUrl, isJoined) => {\n      this.name = name;\n      this.avatarUrl = avatarUrl;\n      this.isJoined = isJoined;\n    });\n\n    _defineProperty(this, \"updateBalance\", async () => {\n      this.balance = await web3.eth.getBalance(this.walletAccount.getAddress().toString('hex'));\n      this.storageManager.setBalance(this.balance);\n      appDispatcher.dispatch({\n        action: Constant.EVENT.ACCOUNT_BALANCE_UPDATED\n      });\n    });\n\n    _defineProperty(this, \"setAskForTransactionApproval\", askForApproval => {\n      this.storageManager.setAskForTransactionApproval(askForApproval);\n      this.askForTransactionApproval = askForApproval;\n    });\n\n    _defineProperty(this, \"loadPrivateKey\", () => {\n      var privateKeyHex = this.storageManager.getPrivateKey();\n\n      if (privateKeyHex) {\n        var privateKeyBuffer = Buffer.from(privateKeyHex, 'hex');\n        this.walletAccount = Wallet.fromPrivateKey(privateKeyBuffer);\n        this.updateBalance();\n      }\n    });\n\n    _defineProperty(this, \"storePrivateKey\", privateKey => {\n      var isValid = false;\n\n      try {\n        var privateKeyBuffer = Buffer.from(privateKey, 'hex');\n        this.walletAccount = Wallet.fromPrivateKey(privateKeyBuffer);\n        this.storageManager.storePrivateKeyAndAddress(privateKey, this.getAddress());\n        isValid = true;\n      } catch (err) {}\n\n      this.updateBalance();\n      return isValid;\n    });\n\n    _defineProperty(this, \"getAddress\", () => {\n      if (this.walletAccount) {\n        return '0x' + this.walletAccount.getAddress().toString('hex');\n      } else {\n        return \"\";\n      }\n    });\n\n    _defineProperty(this, \"computeSecret\", publicKeyBuffer => {\n      var a = crypto.createECDH('secp256k1');\n      a.generateKeys();\n      a.setPrivateKey(this.getPrivateKeyBuffer());\n      return a.computeSecret(publicKeyBuffer);\n    });\n\n    this.isJoined = false;\n    this.balance = 0;\n    this.name = \"\";\n    this.avatarUrl = \"\";\n    this.storageManager = storageManager;\n    this.loadPrivateKey();\n    this.loadInfoFromstorageManager();\n  }\n\n  getPublicKeyBuffer() {\n    return this.walletAccount.getPublicKey();\n  }\n\n  getPrivateKeyBuffer() {\n    return this.walletAccount.getPrivateKey();\n  }\n\n}\n\nexport default AccountManager;","map":{"version":3,"sources":["D:/BlockChat/BlockChat/core/AccountManager.js"],"names":["sha256","Wallet","crypto","web3","utils","EventHandler","appDispatcher","TransactionManager","Constant","Config","AccountManager","constructor","storageManager","balance","getBalance","name","getName","avatarUrl","getAvatarUrl","isJoined","getJoinedStatus","askForTransactionApproval","getAskForTransactionApproval","eth","walletAccount","getAddress","toString","setBalance","dispatch","action","EVENT","ACCOUNT_BALANCE_UPDATED","askForApproval","setAskForTransactionApproval","privateKeyHex","getPrivateKey","privateKeyBuffer","Buffer","from","fromPrivateKey","updateBalance","privateKey","isValid","storePrivateKeyAndAddress","err","publicKeyBuffer","a","createECDH","generateKeys","setPrivateKey","getPrivateKeyBuffer","computeSecret","loadPrivateKey","loadInfoFromstorageManager","getPublicKeyBuffer","getPublicKey"],"mappings":"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","sourcesContent":["import { sha256 } from 'ethereumjs-util';\r\n\r\nimport Wallet from 'ethereumjs-wallet';\r\nimport crypto from 'crypto';\r\nimport web3 from '../ethereum/web3';\r\nimport utils from '../support/Utils';\r\nimport EventHandler from './EventHandler';\r\nimport appDispatcher from '../core/AppDispatcher';\r\nimport TransactionManager from './TransactionManager';\r\nimport Constant from '../support/Constant';\r\nimport Config from '../support/Config';\r\n\r\nclass AccountManager {\r\n    constructor(storageManager) {\r\n        this.isJoined = false;\r\n        this.balance = 0;\r\n        this.name = \"\";\r\n        this.avatarUrl = \"\";\r\n        this.storageManager = storageManager;\r\n        this.loadPrivateKey();\r\n        this.loadInfoFromstorageManager();\r\n    }\r\n\r\n    loadInfoFromstorageManager = () => {\r\n        this.balance = this.storageManager.getBalance();\r\n        this.name = this.storageManager.getName();\r\n        this.avatarUrl = this.storageManager.getAvatarUrl();\r\n        this.isJoined = this.storageManager.getJoinedStatus();\r\n        this.askForTransactionApproval = this.storageManager.getAskForTransactionApproval();\r\n    }\r\n\r\n    setProfile = (name, avatarUrl, isJoined) => {\r\n        this.name = name;\r\n        this.avatarUrl = avatarUrl;\r\n        this.isJoined = isJoined;\r\n    }\r\n\r\n    // Update balance of the current account\r\n    updateBalance = async () => {\r\n        this.balance = await web3.eth.getBalance(this.walletAccount.getAddress().toString('hex'));\r\n        this.storageManager.setBalance(this.balance);\r\n        appDispatcher.dispatch({\r\n            action: Constant.EVENT.ACCOUNT_BALANCE_UPDATED\r\n        })\r\n    }\r\n\r\n    setAskForTransactionApproval = (askForApproval) => {\r\n        this.storageManager.setAskForTransactionApproval(askForApproval);\r\n        this.askForTransactionApproval = askForApproval;\r\n    }\r\n\r\n    // Load private key from browser's local storage\r\n    loadPrivateKey = () => {\r\n        var privateKeyHex = this.storageManager.getPrivateKey();\r\n        if (privateKeyHex) {\r\n            var privateKeyBuffer = Buffer.from(privateKeyHex, 'hex');\r\n            this.walletAccount = Wallet.fromPrivateKey(privateKeyBuffer);\r\n            this.updateBalance();\r\n        }\r\n    }\r\n\r\n    storePrivateKey = (privateKey) => {\r\n        var isValid = false;\r\n        try {\r\n            var privateKeyBuffer = Buffer.from(privateKey, 'hex');\r\n            this.walletAccount = Wallet.fromPrivateKey(privateKeyBuffer);\r\n            this.storageManager.storePrivateKeyAndAddress(privateKey, this.getAddress());\r\n            isValid = true;\r\n        } catch (err) {\r\n        }\r\n        this.updateBalance();\r\n        return isValid;\r\n    }\r\n\r\n    getPublicKeyBuffer() {\r\n        return this.walletAccount.getPublicKey();\r\n    }\r\n\r\n    getPrivateKeyBuffer() {\r\n        return this.walletAccount.getPrivateKey();\r\n    }\r\n\r\n    getAddress = () => {\r\n        if (this.walletAccount) {\r\n            return '0x' + this.walletAccount.getAddress().toString('hex');\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    // Compute a secret key for messages encryption/decryption\r\n    computeSecret = (publicKeyBuffer) => {\r\n        var a = crypto.createECDH('secp256k1');\r\n        a.generateKeys();\r\n        a.setPrivateKey(this.getPrivateKeyBuffer());\r\n        return a.computeSecret(publicKeyBuffer);\r\n    }\r\n}\r\n\r\nexport default AccountManager;"]},"metadata":{},"sourceType":"module"}