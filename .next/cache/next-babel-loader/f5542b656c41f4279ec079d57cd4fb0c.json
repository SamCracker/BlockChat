{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport web3 from '../ethereum/web3';\nimport appDispatcher from '../core/AppDispatcher';\nimport Constant from '../support/Constant';\nimport utils from '../support/Utils'; // EventHandler object currently make requests to the smart contract periodically \n//    to get events initiated by the contract.\n\nclass EventHandler {\n  constructor(myAddress, contractManager, storageManager) {\n    _defineProperty(this, \"pullContactEvents\", async (blockNumber, currentDataBlock) => {\n      // Get list of invitation requests that the current user sent\n      var myRequestEvents = await this.contractManager.getPastEvents('addContactEvent', {\n        filter: {\n          from: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addRequestEvents(myRequestEvents); // Get list of invitation requests from other users send to the current user\n\n      var invitationEvents = await this.contractManager.getPastEvents('addContactEvent', {\n        filter: {\n          to: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addInvitationEvents(invitationEvents);\n\n      for (var i = 0; i < myRequestEvents.length; i++) {\n        await this.contractManager.getMemberInfo(myRequestEvents[i].returnValues.to, Constant.Relationship.Requested);\n      }\n\n      for (var i = 0; i < invitationEvents.length; i++) {\n        await this.contractManager.getMemberInfo(invitationEvents[i].returnValues.from, Constant.Relationship.NoRelation);\n      }\n\n      var myAcceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\n        filter: {\n          from: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addMyAcceptContactEvents(myAcceptContactEvents);\n      var acceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\n        filter: {\n          to: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addAcceptContactEvents(acceptContactEvents); // If the one who accept our contact doesn't have publicKey yet \n      // we need to get it from the smart contract\n\n      for (var i = 0; i < acceptContactEvents.length; i++) {\n        var fromAddress = acceptContactEvents[i].returnValues.from;\n\n        if (!this.storageManager.contacts[fromAddress].publicKey) {\n          await this.contractManager.getMemberInfo(fromAddress, Constant.Relationship.Connected);\n        }\n      } // Get profile update event to check if anyone in the current user contact list has updated their profile\n\n\n      var profileUpdateEvents = await this.contractManager.getPastEvents('profileUpdateEvent', {\n        filter: {\n          from: this.storageManager.contactAddresses\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n\n      for (var i = 0; i < profileUpdateEvents.length; i++) {\n        var eventData = profileUpdateEvents[i].returnValues;\n        this.storageManager.updateContact(eventData.from, \"\", utils.hexStringToAsciiString(eventData.name), utils.hexStringToAsciiString(eventData.avatarUrl), 0);\n      }\n\n      if (myRequestEvents.length > 0 || invitationEvents.length > 0 || profileUpdateEvents.length > 0 || myAcceptContactEvents.length > 0 || acceptContactEvents.length > 0) {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.CONTACT_LIST_UPDATED\n        });\n      }\n    });\n\n    _defineProperty(this, \"pullMessageEvents\", async (blockNumber, currentDataBlock) => {\n      var messagesSent = await this.contractManager.getPastEvents('messageSentEvent', {\n        filter: {\n          from: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      var messagesReceived = await this.contractManager.getPastEvents('messageSentEvent', {\n        filter: {\n          to: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      var iSent = 0;\n      var iReceived = 0;\n\n      while (iSent < messagesSent.length || iReceived < messagesReceived.length) {\n        if (iSent >= messagesSent.length) {\n          this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\n          iReceived++;\n        } else if (iReceived >= messagesReceived.length) {\n          this.storageManager.addMyMessageEvent(messagesSent[iSent]);\n          iSent++;\n        } else {\n          if (messagesSent[iSent].blockNumber < messagesReceived[iReceived].blockNumber) {\n            this.storageManager.addMyMessageEvent(messagesSent[iSent]);\n            iSent++;\n          } else {\n            this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\n            iReceived++;\n          }\n        }\n      }\n\n      if (messagesReceived.length > 0 || messagesSent.length > 0) {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.MESSAGES_UPDATED\n        });\n      }\n    });\n\n    _defineProperty(this, \"pullEvents\", async () => {\n      try {\n        // Get the last updated block number\n        var currentDataBlock = this.storageManager.getCurrentDataBlock();\n        var blockNumber = await web3.eth.getBlockNumber();\n\n        if (blockNumber > currentDataBlock) {\n          await this.pullContactEvents(blockNumber, currentDataBlock);\n          await this.pullMessageEvents(blockNumber, currentDataBlock);\n          this.storageManager.setCurrentDataBlock(blockNumber);\n        }\n      } catch (err) {\n        console.log(err.message);\n      }\n\n      setTimeout(this.pullEvents, 5000);\n    });\n\n    _defineProperty(this, \"start\", () => {\n      this.pullEvents();\n    });\n\n    this.myAddress = myAddress;\n    this.contractManager = contractManager;\n    this.storageManager = storageManager;\n  }\n\n}\n\nexport default EventHandler;","map":{"version":3,"sources":["D:/BlockChat/BlockChat/core/EventHandler.js"],"names":["web3","appDispatcher","Constant","utils","EventHandler","constructor","myAddress","contractManager","storageManager","blockNumber","currentDataBlock","myRequestEvents","getPastEvents","filter","from","fromBlock","toBlock","addRequestEvents","invitationEvents","to","addInvitationEvents","i","length","getMemberInfo","returnValues","Relationship","Requested","NoRelation","myAcceptContactEvents","addMyAcceptContactEvents","acceptContactEvents","addAcceptContactEvents","fromAddress","contacts","publicKey","Connected","profileUpdateEvents","contactAddresses","eventData","updateContact","hexStringToAsciiString","name","avatarUrl","dispatch","action","EVENT","CONTACT_LIST_UPDATED","messagesSent","messagesReceived","iSent","iReceived","addMessageFromFriendEvent","addMyMessageEvent","MESSAGES_UPDATED","getCurrentDataBlock","eth","getBlockNumber","pullContactEvents","pullMessageEvents","setCurrentDataBlock","err","console","log","message","setTimeout","pullEvents"],"mappings":"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","sourcesContent":["import web3 from '../ethereum/web3';\r\nimport appDispatcher from '../core/AppDispatcher';\r\nimport Constant from '../support/Constant';\r\nimport utils from '../support/Utils';\r\n\r\n// EventHandler object currently make requests to the smart contract periodically \r\n//    to get events initiated by the contract.\r\n\r\nclass EventHandler {\r\n    constructor(myAddress, contractManager, storageManager) {\r\n        this.myAddress = myAddress;\r\n        this.contractManager = contractManager;\r\n        this.storageManager = storageManager;\r\n    }\r\n\r\n    pullContactEvents = async (blockNumber, currentDataBlock) => {\r\n\r\n        // Get list of invitation requests that the current user sent\r\n        var myRequestEvents = await this.contractManager.getPastEvents('addContactEvent', {\r\n            filter: {from: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addRequestEvents(myRequestEvents);\r\n\r\n        // Get list of invitation requests from other users send to the current user\r\n        var invitationEvents = await this.contractManager.getPastEvents('addContactEvent', {\r\n            filter: {to: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addInvitationEvents(invitationEvents);\r\n\r\n        for (var i=0;i<myRequestEvents.length;i++) {\r\n            await this.contractManager.getMemberInfo(myRequestEvents[i].returnValues.to, Constant.Relationship.Requested);\r\n        }\r\n        for (var i=0;i<invitationEvents.length;i++) {\r\n            await this.contractManager.getMemberInfo(invitationEvents[i].returnValues.from, Constant.Relationship.NoRelation);\r\n        }\r\n\r\n        var myAcceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\r\n            filter: {from: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addMyAcceptContactEvents(myAcceptContactEvents);\r\n\r\n        var acceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\r\n            filter: {to: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addAcceptContactEvents(acceptContactEvents);\r\n\r\n        // If the one who accept our contact doesn't have publicKey yet \r\n        // we need to get it from the smart contract\r\n        for (var i=0;i<acceptContactEvents.length;i++) {\r\n            var fromAddress = acceptContactEvents[i].returnValues.from;\r\n            if (!this.storageManager.contacts[fromAddress].publicKey) {\r\n                await this.contractManager.getMemberInfo(fromAddress, Constant.Relationship.Connected);\r\n            }\r\n        }\r\n\r\n        // Get profile update event to check if anyone in the current user contact list has updated their profile\r\n        var profileUpdateEvents = await this.contractManager.getPastEvents('profileUpdateEvent', {\r\n            filter: {from: this.storageManager.contactAddresses},\r\n            fromBlock: currentDataBlock + 1,\r\n            toBlock: blockNumber\r\n        });\r\n        \r\n        for (var i=0;i<profileUpdateEvents.length;i++) {\r\n            var eventData = profileUpdateEvents[i].returnValues;\r\n            this.storageManager.updateContact(eventData.from, \"\", \r\n                utils.hexStringToAsciiString(eventData.name), \r\n                utils.hexStringToAsciiString(eventData.avatarUrl), 0);\r\n        }\r\n\r\n        if (myRequestEvents.length > 0 || invitationEvents.length > 0 || \r\n            profileUpdateEvents.length > 0 || myAcceptContactEvents.length > 0 || \r\n            acceptContactEvents.length > 0) {\r\n\r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.CONTACT_LIST_UPDATED\r\n            })\r\n        }\r\n    }\r\n\r\n    pullMessageEvents = async (blockNumber, currentDataBlock) => {\r\n        var messagesSent = await this.contractManager.getPastEvents('messageSentEvent', {\r\n            filter: {from: this.myAddress},\r\n            fromBlock: currentDataBlock + 1,\r\n            toBlock: blockNumber\r\n        });\r\n        var messagesReceived = await this.contractManager.getPastEvents('messageSentEvent', {\r\n            filter: {to: this.myAddress},\r\n            fromBlock: currentDataBlock + 1,\r\n            toBlock: blockNumber\r\n        });\r\n\r\n        var iSent=0;\r\n        var iReceived=0;\r\n        while (iSent < messagesSent.length || iReceived < messagesReceived.length) {\r\n            if (iSent >= messagesSent.length) {\r\n                this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\r\n                iReceived++;\r\n            } else if (iReceived >= messagesReceived.length) {\r\n                this.storageManager.addMyMessageEvent(messagesSent[iSent]);\r\n                iSent++;\r\n            } else {\r\n                if (messagesSent[iSent].blockNumber < messagesReceived[iReceived].blockNumber) {\r\n                    this.storageManager.addMyMessageEvent(messagesSent[iSent]);\r\n                    iSent++;\r\n                } else {\r\n                    this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\r\n                    iReceived++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (messagesReceived.length > 0 || messagesSent.length > 0) {\r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.MESSAGES_UPDATED,\r\n            })\r\n        }\r\n    }\r\n\r\n    pullEvents = async () => {\r\n        try {\r\n            // Get the last updated block number\r\n            var currentDataBlock = this.storageManager.getCurrentDataBlock();\r\n\r\n            var blockNumber = await web3.eth.getBlockNumber();\r\n\r\n            if (blockNumber > currentDataBlock) {\r\n                await this.pullContactEvents(blockNumber, currentDataBlock);\r\n                await this.pullMessageEvents(blockNumber, currentDataBlock);\r\n                this.storageManager.setCurrentDataBlock(blockNumber);\r\n            \r\n            }\r\n        } catch (err) {\r\n            console.log(err.message);\r\n        }\r\n\r\n        setTimeout(this.pullEvents, 5000);\r\n    }\r\n\r\n    start = () => {\r\n        this.pullEvents();\r\n    }\r\n}\r\n\r\nexport default EventHandler;"]},"metadata":{},"sourceType":"module"}