{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nvar _this2 = this;\n\nimport web3 from '../ethereum/web3';\nimport compiledContract from '../ethereum/build/EtherChat.json';\nimport TransactionsManager from './TransactionManager';\nimport appDispatcher from './AppDispatcher';\nimport Config from '../support/Config';\nimport Constant from '../support/Constant';\nimport utils from '../support/Utils'; // import crypto from 'crypto';\n\n/**\r\n * Responsible for interacting with the Ethereum smart contract\r\n */\n\nvar ContractManager = /*#__PURE__*/function () {\n  function ContractManager(accountManager, storageManager) {\n    var _this = this;\n\n    _classCallCheck(this, ContractManager);\n\n    _defineProperty(this, \"getContract\", function _callee() {\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regeneratorRuntime.awrap(new web3.eth.Contract(JSON.parse(compiledContract[\"interface\"]), Config.ENV.ContractAddress));\n\n            case 2:\n              _this.contract = _context.sent;\n              appDispatcher.dispatch({\n                action: Constant.EVENT.CONTRACT_READY\n              });\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      });\n    });\n\n    _defineProperty(this, \"getProfile\", function _callee2(address) {\n      var result, profile;\n      return _regeneratorRuntime.async(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _regeneratorRuntime.awrap(_this.contract.methods.members(_this.accountManager.getAddress()).call());\n\n            case 2:\n              result = _context2.sent;\n              profile = {};\n\n              if (result.isMember == 1) {\n                profile.isJoined = true;\n                profile.avatarUrl = utils.hexStringToAsciiString(result.avatarUrl);\n                profile.name = utils.hexStringToAsciiString(result.name);\n\n                _this.storageManager.setJoinedStatus(true);\n\n                _this.storageManager.setName(_this.name);\n\n                _this.storageManager.setAvatarUrl(_this.avatarUrl);\n\n                appDispatcher.dispatch({\n                  action: Constant.EVENT.ACCOUNT_INFO_UPDATED,\n                  profile: profile\n                });\n              }\n\n              return _context2.abrupt(\"return\", profile);\n\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      });\n    });\n\n    _defineProperty(this, \"getMemberInfo\", function _callee3(address, relationship) {\n      var memberInfo, publicKey, name, avatarUrl;\n      return _regeneratorRuntime.async(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return _regeneratorRuntime.awrap(_this.contract.methods.members(address).call());\n\n            case 2:\n              memberInfo = _context3.sent;\n\n              if (memberInfo.isMember) {\n                publicKey = '04' + memberInfo.publicKeyLeft.substr(2) + memberInfo.publicKeyRight.substr(2);\n                name = utils.hexStringToAsciiString(memberInfo.name);\n                avatarUrl = utils.hexStringToAsciiString(memberInfo.avatarUrl);\n\n                _this.storageManager.updateContact(address, publicKey, name, avatarUrl, relationship);\n              }\n\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      });\n    });\n\n    _defineProperty(this, \"getPastEvents\", function _callee4(eventName, filters) {\n      return _regeneratorRuntime.async(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return _regeneratorRuntime.awrap(_this.contract.getPastEvents(eventName, filters));\n\n            case 2:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      });\n    });\n\n    this.getContract();\n    this.accountManager = accountManager;\n    this.storageManager = storageManager;\n    this.transactionManager = new TransactionsManager(accountManager);\n  } // Create a web3 contract object that represent the ethereum smart contract\n\n\n  _createClass(ContractManager, [{\n    key: \"joinContract\",\n    value: function joinContract(publicKeyBuffer, callback) {\n      var publicKeyLeft, publicKeyRight;\n      return _regeneratorRuntime.async(function joinContract$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              publicKeyLeft = '0x' + publicKeyBuffer.toString('hex', 0, 32);\n              publicKeyRight = '0x' + publicKeyBuffer.toString('hex', 32, 64);\n              this.transactionManager.executeMethod(this.contract.methods.join(publicKeyLeft, publicKeyRight)).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\n              }).on(Constant.EVENT.ON_REJECTED, function (txHash) {\n                if (callback) callback(Constant.EVENT.ON_REJECTED);\n              }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\n              }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n                appDispatcher.dispatch({\n                  action: Constant.EVENT.ENCOUNTERED_ERROR,\n                  message: error.message,\n                  title: \"Error\"\n                });\n                if (callback) callback(Constant.EVENT.ON_ERROR);\n              });\n\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this);\n    }\n  }]);\n\n  return ContractManager;\n}();\n\njoinContract = function joinContract(publicKeyBuffer, callback) {\n  return _regeneratorRuntime.async(function joinContract$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          addContact = function addContact(address, callback) {\n            var method;\n            return _regeneratorRuntime.async(function addContact$(_context6) {\n              while (1) {\n                switch (_context6.prev = _context6.next) {\n                  case 0:\n                    console.log(address);\n                    method = _this2.contract.methods.addContact(address);\n\n                    _this2.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n                      if (callback) callback(Constant.EVENT.ON_APPROVED);\n                    }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n                      if (callback) callback(Constant.EVENT.ON_RECEIPT);\n                    }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n                      appDispatcher.dispatch({\n                        action: Constant.EVENT.ENCOUNTERED_ERROR,\n                        message: error.message,\n                        title: \"Error\"\n                      });\n                      if (callback) callback(Constant.EVENT.ON_ERROR);\n                    });\n\n                  case 3:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }\n            });\n          };\n\n          acceptContactRequest = function acceptContactRequest(address, callback) {\n            var method;\n            return _regeneratorRuntime.async(function acceptContactRequest$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    method = _this2.contract.methods.acceptContactRequest(address);\n\n                    _this2.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n                      if (callback) callback(Constant.EVENT.ON_APPROVED);\n                    }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n                      if (callback) callback(Constant.EVENT.ON_RECEIPT);\n                    }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n                      appDispatcher.dispatch({\n                        action: Constant.EVENT.ENCOUNTERED_ERROR,\n                        message: error.message,\n                        title: \"Error\"\n                      });\n                      if (callback) callback(Constant.EVENT.ON_ERROR);\n                    });\n\n                  case 2:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            });\n          };\n\n          updateProfile = function updateProfile(name, avatarUrl, callback) {\n            var nameHex, avatarUrlHex, method;\n            return _regeneratorRuntime.async(function updateProfile$(_context8) {\n              while (1) {\n                switch (_context8.prev = _context8.next) {\n                  case 0:\n                    nameHex = '0x' + Buffer.from(name, 'ascii').toString('hex');\n                    avatarUrlHex = '0x' + Buffer.from(avatarUrl, 'ascii').toString('hex');\n                    method = _this2.contract.methods.updateProfile(nameHex, avatarUrlHex);\n\n                    _this2.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n                      if (callback) callback(Constant.EVENT.ON_APPROVED);\n                    }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n                      if (callback) callback(Constant.EVENT.ON_RECEIPT);\n                    }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n                      appDispatcher.dispatch({\n                        action: Constant.EVENT.ENCOUNTERED_ERROR,\n                        message: error.message,\n                        title: \"Error\"\n                      });\n                      if (callback) callback(Constant.EVENT.ON_ERROR);\n                    });\n\n                  case 4:\n                  case \"end\":\n                    return _context8.stop();\n                }\n              }\n            });\n          }; // A message will be encrypted locally before sending to the smart contract\n\n\n          sendMessage = function sendMessage(toAddress, publicKey, message) {\n            var publicKeyBuffer, encryptedRaw, encryptedMessage, method;\n            return _regeneratorRuntime.async(function sendMessage$(_context9) {\n              while (1) {\n                switch (_context9.prev = _context9.next) {\n                  case 0:\n                    publicKeyBuffer = Buffer.from(publicKey, 'hex');\n                    encryptedRaw = utils.encrypt(message, _this2.accountManager.computeSecret(publicKeyBuffer));\n                    encryptedMessage = '0x' + encryptedRaw.toString('hex');\n                    method = _this2.contract.methods.sendMessage(toAddress, encryptedMessage, utils.getEncryptAlgorithmInHex());\n\n                    _this2.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n                      _this2.storageManager.addMyLocalMessage(encryptedMessage, toAddress, utils.getEncryptAlgorithm(), txHash);\n\n                      appDispatcher.dispatch({\n                        action: Constant.EVENT.MESSAGES_UPDATED,\n                        data: toAddress\n                      });\n                    }).on(Constant.EVENT.ON_REJECTED, function (data) {// do nothing\n                    }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n                      _this2.storageManager.updateLocalMessage(toAddress, receipt.transactionHash, Constant.SENT_STATUS.SUCCESS);\n\n                      appDispatcher.dispatch({\n                        action: Constant.EVENT.MESSAGES_UPDATED,\n                        data: toAddress\n                      });\n                    }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n                      _this2.storageManager.updateLocalMessage(toAddress, txHash, Constant.SENT_STATUS.FAILED);\n\n                      appDispatcher.dispatch({\n                        action: Constant.EVENT.MESSAGES_UPDATED,\n                        data: toAddress\n                      });\n                    });\n\n                  case 5:\n                  case \"end\":\n                    return _context9.stop();\n                }\n              }\n            });\n          };\n\n        case 4:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  });\n};\n\nexport default ContractManager;","map":{"version":3,"sources":["D:/BlockChat/BlockChat/core/ContractManager.js"],"names":["web3","compiledContract","TransactionsManager","appDispatcher","Config","Constant","utils","ContractManager","accountManager","storageManager","eth","Contract","JSON","parse","ENV","ContractAddress","contract","dispatch","action","EVENT","CONTRACT_READY","address","methods","members","getAddress","call","result","profile","isMember","isJoined","avatarUrl","hexStringToAsciiString","name","setJoinedStatus","setName","setAvatarUrl","ACCOUNT_INFO_UPDATED","relationship","memberInfo","publicKey","publicKeyLeft","substr","publicKeyRight","updateContact","eventName","filters","getPastEvents","getContract","transactionManager","publicKeyBuffer","callback","toString","executeMethod","join","on","ON_APPROVED","txHash","ON_REJECTED","ON_RECEIPT","receipt","ON_ERROR","error","ENCOUNTERED_ERROR","message","title","joinContract","addContact","console","log","method","acceptContactRequest","updateProfile","nameHex","Buffer","from","avatarUrlHex","sendMessage","toAddress","encryptedRaw","encrypt","computeSecret","encryptedMessage","getEncryptAlgorithmInHex","addMyLocalMessage","getEncryptAlgorithm","MESSAGES_UPDATED","data","updateLocalMessage","transactionHash","SENT_STATUS","SUCCESS","FAILED"],"mappings":"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","sourcesContent":["import web3 from '../ethereum/web3';\r\nimport compiledContract from '../ethereum/build/EtherChat.json';\r\nimport TransactionsManager from './TransactionManager';\r\nimport appDispatcher from './AppDispatcher';\r\nimport Config from '../support/Config';\r\nimport Constant from '../support/Constant';\r\nimport utils from '../support/Utils';\r\n// import crypto from 'crypto';\r\n\r\n/**\r\n * Responsible for interacting with the Ethereum smart contract\r\n */\r\n\r\nclass ContractManager {\r\n    constructor(accountManager, storageManager) {\r\n        this.getContract();\r\n        this.accountManager = accountManager;\r\n        this.storageManager = storageManager;\r\n        this.transactionManager = new TransactionsManager(accountManager);\r\n    }\r\n\r\n    // Create a web3 contract object that represent the ethereum smart contract\r\n    getContract = async () => {\r\n        this.contract = await new web3.eth.Contract(JSON.parse(compiledContract.interface), \r\n                Config.ENV.ContractAddress);\r\n        appDispatcher.dispatch({\r\n            action: Constant.EVENT.CONTRACT_READY\r\n        })\r\n    }\r\n\r\n    // Get current account profile from EtherChat contract's storage\r\n    getProfile = async (address) => {\r\n        var result = await this.contract.methods.members(this.accountManager.getAddress()).call();\r\n        var profile = {};\r\n        if (result.isMember == 1) {\r\n            profile.isJoined = true;\r\n            profile.avatarUrl = utils.hexStringToAsciiString(result.avatarUrl);\r\n            profile.name = utils.hexStringToAsciiString(result.name);\r\n\r\n            this.storageManager.setJoinedStatus(true);\r\n            this.storageManager.setName(this.name);\r\n            this.storageManager.setAvatarUrl(this.avatarUrl);\r\n            \r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.ACCOUNT_INFO_UPDATED,\r\n                profile: profile\r\n            })\r\n        }\r\n        return profile;\r\n    }\r\n\r\n    getMemberInfo = async (address, relationship) => {\r\n        var memberInfo = await this.contract.methods.members(address).call();\r\n        if (memberInfo.isMember) {\r\n            var publicKey = '04' + memberInfo.publicKeyLeft.substr(2) + memberInfo.publicKeyRight.substr(2);\r\n            var name = utils.hexStringToAsciiString(memberInfo.name);\r\n            var avatarUrl = utils.hexStringToAsciiString(memberInfo.avatarUrl);\r\n            this.storageManager.updateContact(address, publicKey, name, avatarUrl, relationship);\r\n        }\r\n    }\r\n\r\n    getPastEvents = async (eventName, filters) => {\r\n        return await this.contract.getPastEvents(eventName, filters);\r\n    }\r\n\r\n    async joinContract(publicKeyBuffer, callback) {\r\n        var publicKeyLeft = '0x' + publicKeyBuffer.toString('hex', 0, 32);\r\n    var publicKeyRight = '0x' + publicKeyBuffer.toString('hex', 32, 64);\r\n\r\n    this.transactionManager.executeMethod(this.contract.methods.join(publicKeyLeft, publicKeyRight))\r\n        .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n            if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n        })\r\n        .on(Constant.EVENT.ON_REJECTED, (txHash) => {\r\n            if (callback) callback(Constant.EVENT.ON_REJECTED);\r\n        })\r\n        .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n            if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n        })\r\n        .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                message: error.message,\r\n                title: \"Error\"\r\n            });\r\n            if (callback) callback(Constant.EVENT.ON_ERROR);\r\n        });\r\n    }\r\n    \r\n}\r\n    joinContract = async (publicKeyBuffer, callback) => {\r\n\r\n    addContact = async (address, callback) => {\r\n        console.log(address);\r\n\r\n        var method = this.contract.methods.addContact(address);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    acceptContactRequest = async (address, callback) => {\r\n        var method = this.contract.methods.acceptContactRequest(address);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    updateProfile = async (name, avatarUrl, callback) => {\r\n        var nameHex = '0x' + Buffer.from(name, 'ascii').toString('hex');\r\n        var avatarUrlHex = '0x' + Buffer.from(avatarUrl, 'ascii').toString('hex');\r\n        var method = this.contract.methods.updateProfile(nameHex, avatarUrlHex);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    // A message will be encrypted locally before sending to the smart contract\r\n    sendMessage = async (toAddress, publicKey, message) => {\r\n        var publicKeyBuffer = Buffer.from(publicKey, 'hex');\r\n        var encryptedRaw = utils.encrypt(message, this.accountManager.computeSecret(publicKeyBuffer));\r\n        var encryptedMessage = '0x' + encryptedRaw.toString('hex');\r\n        var method = this.contract.methods.sendMessage(toAddress, encryptedMessage, utils.getEncryptAlgorithmInHex());\r\n\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                this.storageManager.addMyLocalMessage(encryptedMessage, toAddress, utils.getEncryptAlgorithm(), txHash);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            })\r\n            .on(Constant.EVENT.ON_REJECTED, (data) => {\r\n                // do nothing\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt, ) => {\r\n                this.storageManager.updateLocalMessage(toAddress, receipt.transactionHash, Constant.SENT_STATUS.SUCCESS);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                this.storageManager.updateLocalMessage(toAddress, txHash, Constant.SENT_STATUS.FAILED);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            });\r\n    }\r\n}\r\n\r\nexport default ContractManager;"]},"metadata":{},"sourceType":"module"}