{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport web3 from '../ethereum/web3';\nimport compiledContract from '../ethereum/build/EtherChat.json';\nimport TransactionsManager from './TransactionManager';\nimport appDispatcher from './AppDispatcher';\nimport Config from '../support/Config';\nimport Constant from '../support/Constant';\nimport utils from '../support/Utils'; // import crypto from 'crypto';\n\n/**\r\n * Responsible for interacting with the Ethereum smart contract\r\n */\n\nclass ContractManager {\n  constructor(accountManager, storageManager) {\n    _defineProperty(this, \"getContract\", async () => {\n      this.contract = await new web3.eth.Contract(JSON.parse(compiledContract.interface), Config.ENV.ContractAddress);\n      appDispatcher.dispatch({\n        action: Constant.EVENT.CONTRACT_READY\n      });\n    });\n\n    _defineProperty(this, \"getProfile\", async address => {\n      var result = await this.contract.methods.members(this.accountManager.getAddress()).call();\n      var profile = {};\n\n      if (result.isMember == 1) {\n        profile.isJoined = true;\n        profile.avatarUrl = utils.hexStringToAsciiString(result.avatarUrl);\n        profile.name = utils.hexStringToAsciiString(result.name);\n        this.storageManager.setJoinedStatus(true);\n        this.storageManager.setName(this.name);\n        this.storageManager.setAvatarUrl(this.avatarUrl);\n        appDispatcher.dispatch({\n          action: Constant.EVENT.ACCOUNT_INFO_UPDATED,\n          profile: profile\n        });\n      }\n\n      return profile;\n    });\n\n    _defineProperty(this, \"getMemberInfo\", async (address, relationship) => {\n      var memberInfo = await this.contract.methods.members(address).call();\n\n      if (memberInfo.isMember) {\n        var publicKey = '04' + memberInfo.publicKeyLeft.substr(2) + memberInfo.publicKeyRight.substr(2);\n        var name = utils.hexStringToAsciiString(memberInfo.name);\n        var avatarUrl = utils.hexStringToAsciiString(memberInfo.avatarUrl);\n        this.storageManager.updateContact(address, publicKey, name, avatarUrl, relationship);\n      }\n    });\n\n    _defineProperty(this, \"getPastEvents\", async (eventName, filters) => {\n      return await this.contract.getPastEvents(eventName, filters);\n    });\n\n    _defineProperty(this, \"joinContract\", async (publicKeyBuffer, callback) => {\n      var publicKeyLeft = '0x' + publicKeyBuffer.toString('hex', 0, 32);\n      var publicKeyRight = '0x' + publicKeyBuffer.toString('hex', 32, 64);\n      this.transactionManager.executeMethod(this.contract.methods.join(publicKeyLeft, publicKeyRight)).on(Constant.EVENT.ON_APPROVED, txHash => {\n        if (callback) callback(Constant.EVENT.ON_APPROVED);\n      }).on(Constant.EVENT.ON_REJECTED, txHash => {\n        if (callback) callback(Constant.EVENT.ON_REJECTED);\n      }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n        if (callback) callback(Constant.EVENT.ON_RECEIPT);\n      }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.ENCOUNTERED_ERROR,\n          message: error.message,\n          title: \"Error\"\n        });\n        if (callback) callback(Constant.EVENT.ON_ERROR);\n      });\n    });\n\n    _defineProperty(this, \"addContact\", async (address, callback) => {\n      console.log(address);\n      var method = this.contract.methods.addContact(address);\n      this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n        if (callback) callback(Constant.EVENT.ON_APPROVED);\n      }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n        if (callback) callback(Constant.EVENT.ON_RECEIPT);\n      }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.ENCOUNTERED_ERROR,\n          message: error.message,\n          title: \"Error\"\n        });\n        if (callback) callback(Constant.EVENT.ON_ERROR);\n      });\n    });\n\n    _defineProperty(this, \"acceptContactRequest\", async (address, callback) => {\n      var method = this.contract.methods.acceptContactRequest(address);\n      this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n        if (callback) callback(Constant.EVENT.ON_APPROVED);\n      }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n        if (callback) callback(Constant.EVENT.ON_RECEIPT);\n      }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.ENCOUNTERED_ERROR,\n          message: error.message,\n          title: \"Error\"\n        });\n        if (callback) callback(Constant.EVENT.ON_ERROR);\n      });\n    });\n\n    _defineProperty(this, \"updateProfile\", async (name, avatarUrl, callback) => {\n      var nameHex = '0x' + Buffer.from(name, 'ascii').toString('hex');\n      var avatarUrlHex = '0x' + Buffer.from(avatarUrl, 'ascii').toString('hex');\n      var method = this.contract.methods.updateProfile(nameHex, avatarUrlHex);\n      this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n        if (callback) callback(Constant.EVENT.ON_APPROVED);\n      }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n        if (callback) callback(Constant.EVENT.ON_RECEIPT);\n      }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.ENCOUNTERED_ERROR,\n          message: error.message,\n          title: \"Error\"\n        });\n        if (callback) callback(Constant.EVENT.ON_ERROR);\n      });\n    });\n\n    _defineProperty(this, \"sendMessage\", async (toAddress, publicKey, message) => {\n      var publicKeyBuffer = Buffer.from(publicKey, 'hex');\n      var encryptedRaw = utils.encrypt(message, this.accountManager.computeSecret(publicKeyBuffer));\n      var encryptedMessage = '0x' + encryptedRaw.toString('hex');\n      var method = this.contract.methods.sendMessage(toAddress, encryptedMessage, utils.getEncryptAlgorithmInHex());\n      this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n        this.storageManager.addMyLocalMessage(encryptedMessage, toAddress, utils.getEncryptAlgorithm(), txHash);\n        appDispatcher.dispatch({\n          action: Constant.EVENT.MESSAGES_UPDATED,\n          data: toAddress\n        });\n      }).on(Constant.EVENT.ON_REJECTED, data => {// do nothing\n      }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n        this.storageManager.updateLocalMessage(toAddress, receipt.transactionHash, Constant.SENT_STATUS.SUCCESS);\n        appDispatcher.dispatch({\n          action: Constant.EVENT.MESSAGES_UPDATED,\n          data: toAddress\n        });\n      }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n        this.storageManager.updateLocalMessage(toAddress, txHash, Constant.SENT_STATUS.FAILED);\n        appDispatcher.dispatch({\n          action: Constant.EVENT.MESSAGES_UPDATED,\n          data: toAddress\n        });\n      });\n    });\n\n    this.getContract();\n    this.accountManager = accountManager;\n    this.storageManager = storageManager;\n    this.transactionManager = new TransactionsManager(accountManager);\n  } // Create a web3 contract object that represent the ethereum smart contract\n\n\n}\n\nexport default ContractManager;","map":null,"metadata":{},"sourceType":"module"}