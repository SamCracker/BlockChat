{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport web3 from '../ethereum/web3';\nimport appDispatcher from '../core/AppDispatcher';\nimport Constant from '../support/Constant';\nimport utils from '../support/Utils'; // EventHandler object currently make requests to the smart contract periodically \n//    to get events initiated by the contract.\n\nvar EventHandler = function EventHandler(myAddress, contractManager, storageManager) {\n  var _this = this;\n\n  _classCallCheck(this, EventHandler);\n\n  _defineProperty(this, \"pullContactEvents\", function _callee(blockNumber, currentDataBlock) {\n    var myRequestEvents, invitationEvents, i, myAcceptContactEvents, acceptContactEvents, fromAddress, profileUpdateEvents, eventData;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _regeneratorRuntime.awrap(_this.contractManager.getPastEvents('addContactEvent', {\n              filter: {\n                from: _this.myAddress\n              },\n              fromBlock: currentDataBlock + 1,\n              toBlock: blockNumber\n            }));\n\n          case 2:\n            myRequestEvents = _context.sent;\n\n            _this.storageManager.addRequestEvents(myRequestEvents); // Get list of invitation requests from other users send to the current user\n\n\n            _context.next = 6;\n            return _regeneratorRuntime.awrap(_this.contractManager.getPastEvents('addContactEvent', {\n              filter: {\n                to: _this.myAddress\n              },\n              fromBlock: currentDataBlock + 1,\n              toBlock: blockNumber\n            }));\n\n          case 6:\n            invitationEvents = _context.sent;\n\n            _this.storageManager.addInvitationEvents(invitationEvents);\n\n            i = 0;\n\n          case 9:\n            if (!(i < myRequestEvents.length)) {\n              _context.next = 15;\n              break;\n            }\n\n            _context.next = 12;\n            return _regeneratorRuntime.awrap(_this.contractManager.getMemberInfo(myRequestEvents[i].returnValues.to, Constant.Relationship.Requested));\n\n          case 12:\n            i++;\n            _context.next = 9;\n            break;\n\n          case 15:\n            i = 0;\n\n          case 16:\n            if (!(i < invitationEvents.length)) {\n              _context.next = 22;\n              break;\n            }\n\n            _context.next = 19;\n            return _regeneratorRuntime.awrap(_this.contractManager.getMemberInfo(invitationEvents[i].returnValues.from, Constant.Relationship.NoRelation));\n\n          case 19:\n            i++;\n            _context.next = 16;\n            break;\n\n          case 22:\n            _context.next = 24;\n            return _regeneratorRuntime.awrap(_this.contractManager.getPastEvents('acceptContactEvent', {\n              filter: {\n                from: _this.myAddress\n              },\n              fromBlock: currentDataBlock + 1,\n              toBlock: blockNumber\n            }));\n\n          case 24:\n            myAcceptContactEvents = _context.sent;\n\n            _this.storageManager.addMyAcceptContactEvents(myAcceptContactEvents);\n\n            _context.next = 28;\n            return _regeneratorRuntime.awrap(_this.contractManager.getPastEvents('acceptContactEvent', {\n              filter: {\n                to: _this.myAddress\n              },\n              fromBlock: currentDataBlock + 1,\n              toBlock: blockNumber\n            }));\n\n          case 28:\n            acceptContactEvents = _context.sent;\n\n            _this.storageManager.addAcceptContactEvents(acceptContactEvents); // If the one who accept our contact doesn't have publicKey yet \n            // we need to get it from the smart contract\n\n\n            i = 0;\n\n          case 31:\n            if (!(i < acceptContactEvents.length)) {\n              _context.next = 39;\n              break;\n            }\n\n            fromAddress = acceptContactEvents[i].returnValues.from;\n\n            if (_this.storageManager.contacts[fromAddress].publicKey) {\n              _context.next = 36;\n              break;\n            }\n\n            _context.next = 36;\n            return _regeneratorRuntime.awrap(_this.contractManager.getMemberInfo(fromAddress, Constant.Relationship.Connected));\n\n          case 36:\n            i++;\n            _context.next = 31;\n            break;\n\n          case 39:\n            _context.next = 41;\n            return _regeneratorRuntime.awrap(_this.contractManager.getPastEvents('profileUpdateEvent', {\n              filter: {\n                from: _this.storageManager.contactAddresses\n              },\n              fromBlock: currentDataBlock + 1,\n              toBlock: blockNumber\n            }));\n\n          case 41:\n            profileUpdateEvents = _context.sent;\n\n            for (i = 0; i < profileUpdateEvents.length; i++) {\n              eventData = profileUpdateEvents[i].returnValues;\n\n              _this.storageManager.updateContact(eventData.from, \"\", utils.hexStringToAsciiString(eventData.name), utils.hexStringToAsciiString(eventData.avatarUrl), 0);\n            }\n\n            if (myRequestEvents.length > 0 || invitationEvents.length > 0 || profileUpdateEvents.length > 0 || myAcceptContactEvents.length > 0 || acceptContactEvents.length > 0) {\n              appDispatcher.dispatch({\n                action: Constant.EVENT.CONTACT_LIST_UPDATED\n              });\n            }\n\n          case 44:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"pullMessageEvents\", function _callee2(blockNumber, currentDataBlock) {\n    var messagesSent, messagesReceived, iSent, iReceived;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _regeneratorRuntime.awrap(_this.contractManager.getPastEvents('messageSentEvent', {\n              filter: {\n                from: _this.myAddress\n              },\n              fromBlock: currentDataBlock + 1,\n              toBlock: blockNumber\n            }));\n\n          case 2:\n            messagesSent = _context2.sent;\n            _context2.next = 5;\n            return _regeneratorRuntime.awrap(_this.contractManager.getPastEvents('messageSentEvent', {\n              filter: {\n                to: _this.myAddress\n              },\n              fromBlock: currentDataBlock + 1,\n              toBlock: blockNumber\n            }));\n\n          case 5:\n            messagesReceived = _context2.sent;\n            iSent = 0;\n            iReceived = 0;\n\n            while (iSent < messagesSent.length || iReceived < messagesReceived.length) {\n              if (iSent >= messagesSent.length) {\n                _this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\n\n                iReceived++;\n              } else if (iReceived >= messagesReceived.length) {\n                _this.storageManager.addMyMessageEvent(messagesSent[iSent]);\n\n                iSent++;\n              } else {\n                if (messagesSent[iSent].blockNumber < messagesReceived[iReceived].blockNumber) {\n                  _this.storageManager.addMyMessageEvent(messagesSent[iSent]);\n\n                  iSent++;\n                } else {\n                  _this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\n\n                  iReceived++;\n                }\n              }\n            }\n\n            if (messagesReceived.length > 0 || messagesSent.length > 0) {\n              appDispatcher.dispatch({\n                action: Constant.EVENT.MESSAGES_UPDATED\n              });\n            }\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"pullEvents\", function _callee3() {\n    var currentDataBlock, blockNumber;\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            // Get the last updated block number\n            currentDataBlock = _this.storageManager.getCurrentDataBlock();\n            _context3.next = 4;\n            return _regeneratorRuntime.awrap(web3.eth.getBlockNumber());\n\n          case 4:\n            blockNumber = _context3.sent;\n\n            if (!(blockNumber > currentDataBlock)) {\n              _context3.next = 11;\n              break;\n            }\n\n            _context3.next = 8;\n            return _regeneratorRuntime.awrap(_this.pullContactEvents(blockNumber, currentDataBlock));\n\n          case 8:\n            _context3.next = 10;\n            return _regeneratorRuntime.awrap(_this.pullMessageEvents(blockNumber, currentDataBlock));\n\n          case 10:\n            _this.storageManager.setCurrentDataBlock(blockNumber);\n\n          case 11:\n            _context3.next = 16;\n            break;\n\n          case 13:\n            _context3.prev = 13;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.log(_context3.t0.message);\n\n          case 16:\n            setTimeout(_this.pullEvents, 5000);\n\n          case 17:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, [[0, 13]]);\n  });\n\n  _defineProperty(this, \"start\", function () {\n    _this.pullEvents();\n  });\n\n  this.myAddress = myAddress;\n  this.contractManager = contractManager;\n  this.storageManager = storageManager;\n};\n\nexport default EventHandler;","map":{"version":3,"sources":["D:/BlockChat/BlockChat/core/EventHandler.js"],"names":["web3","appDispatcher","Constant","utils","EventHandler","myAddress","contractManager","storageManager","blockNumber","currentDataBlock","getPastEvents","filter","from","fromBlock","toBlock","myRequestEvents","addRequestEvents","to","invitationEvents","addInvitationEvents","i","length","getMemberInfo","returnValues","Relationship","Requested","NoRelation","myAcceptContactEvents","addMyAcceptContactEvents","acceptContactEvents","addAcceptContactEvents","fromAddress","contacts","publicKey","Connected","contactAddresses","profileUpdateEvents","eventData","updateContact","hexStringToAsciiString","name","avatarUrl","dispatch","action","EVENT","CONTACT_LIST_UPDATED","messagesSent","messagesReceived","iSent","iReceived","addMessageFromFriendEvent","addMyMessageEvent","MESSAGES_UPDATED","getCurrentDataBlock","eth","getBlockNumber","pullContactEvents","pullMessageEvents","setCurrentDataBlock","console","log","message","setTimeout","pullEvents"],"mappings":"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","sourcesContent":["import web3 from '../ethereum/web3';\r\nimport appDispatcher from '../core/AppDispatcher';\r\nimport Constant from '../support/Constant';\r\nimport utils from '../support/Utils';\r\n\r\n// EventHandler object currently make requests to the smart contract periodically \r\n//    to get events initiated by the contract.\r\n\r\nclass EventHandler {\r\n    constructor(myAddress, contractManager, storageManager) {\r\n        this.myAddress = myAddress;\r\n        this.contractManager = contractManager;\r\n        this.storageManager = storageManager;\r\n    }\r\n\r\n    pullContactEvents = async (blockNumber, currentDataBlock) => {\r\n\r\n        // Get list of invitation requests that the current user sent\r\n        var myRequestEvents = await this.contractManager.getPastEvents('addContactEvent', {\r\n            filter: {from: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addRequestEvents(myRequestEvents);\r\n\r\n        // Get list of invitation requests from other users send to the current user\r\n        var invitationEvents = await this.contractManager.getPastEvents('addContactEvent', {\r\n            filter: {to: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addInvitationEvents(invitationEvents);\r\n\r\n        for (var i=0;i<myRequestEvents.length;i++) {\r\n            await this.contractManager.getMemberInfo(myRequestEvents[i].returnValues.to, Constant.Relationship.Requested);\r\n        }\r\n        for (var i=0;i<invitationEvents.length;i++) {\r\n            await this.contractManager.getMemberInfo(invitationEvents[i].returnValues.from, Constant.Relationship.NoRelation);\r\n        }\r\n\r\n        var myAcceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\r\n            filter: {from: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addMyAcceptContactEvents(myAcceptContactEvents);\r\n\r\n        var acceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\r\n            filter: {to: this.myAddress},\r\n            fromBlock: currentDataBlock+1,\r\n            toBlock: blockNumber\r\n        });\r\n        this.storageManager.addAcceptContactEvents(acceptContactEvents);\r\n\r\n        // If the one who accept our contact doesn't have publicKey yet \r\n        // we need to get it from the smart contract\r\n        for (var i=0;i<acceptContactEvents.length;i++) {\r\n            var fromAddress = acceptContactEvents[i].returnValues.from;\r\n            if (!this.storageManager.contacts[fromAddress].publicKey) {\r\n                await this.contractManager.getMemberInfo(fromAddress, Constant.Relationship.Connected);\r\n            }\r\n        }\r\n\r\n        // Get profile update event to check if anyone in the current user contact list has updated their profile\r\n        var profileUpdateEvents = await this.contractManager.getPastEvents('profileUpdateEvent', {\r\n            filter: {from: this.storageManager.contactAddresses},\r\n            fromBlock: currentDataBlock + 1,\r\n            toBlock: blockNumber\r\n        });\r\n        \r\n        for (var i=0;i<profileUpdateEvents.length;i++) {\r\n            var eventData = profileUpdateEvents[i].returnValues;\r\n            this.storageManager.updateContact(eventData.from, \"\", \r\n                utils.hexStringToAsciiString(eventData.name), \r\n                utils.hexStringToAsciiString(eventData.avatarUrl), 0);\r\n        }\r\n\r\n        if (myRequestEvents.length > 0 || invitationEvents.length > 0 || \r\n            profileUpdateEvents.length > 0 || myAcceptContactEvents.length > 0 || \r\n            acceptContactEvents.length > 0) {\r\n\r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.CONTACT_LIST_UPDATED\r\n            })\r\n        }\r\n    }\r\n\r\n    pullMessageEvents = async (blockNumber, currentDataBlock) => {\r\n        var messagesSent = await this.contractManager.getPastEvents('messageSentEvent', {\r\n            filter: {from: this.myAddress},\r\n            fromBlock: currentDataBlock + 1,\r\n            toBlock: blockNumber\r\n        });\r\n        var messagesReceived = await this.contractManager.getPastEvents('messageSentEvent', {\r\n            filter: {to: this.myAddress},\r\n            fromBlock: currentDataBlock + 1,\r\n            toBlock: blockNumber\r\n        });\r\n\r\n        var iSent=0;\r\n        var iReceived=0;\r\n        while (iSent < messagesSent.length || iReceived < messagesReceived.length) {\r\n            if (iSent >= messagesSent.length) {\r\n                this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\r\n                iReceived++;\r\n            } else if (iReceived >= messagesReceived.length) {\r\n                this.storageManager.addMyMessageEvent(messagesSent[iSent]);\r\n                iSent++;\r\n            } else {\r\n                if (messagesSent[iSent].blockNumber < messagesReceived[iReceived].blockNumber) {\r\n                    this.storageManager.addMyMessageEvent(messagesSent[iSent]);\r\n                    iSent++;\r\n                } else {\r\n                    this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\r\n                    iReceived++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (messagesReceived.length > 0 || messagesSent.length > 0) {\r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.MESSAGES_UPDATED,\r\n            })\r\n        }\r\n    }\r\n\r\n    pullEvents = async () => {\r\n        try {\r\n            // Get the last updated block number\r\n            var currentDataBlock = this.storageManager.getCurrentDataBlock();\r\n\r\n            var blockNumber = await web3.eth.getBlockNumber();\r\n\r\n            if (blockNumber > currentDataBlock) {\r\n                await this.pullContactEvents(blockNumber, currentDataBlock);\r\n                await this.pullMessageEvents(blockNumber, currentDataBlock);\r\n                this.storageManager.setCurrentDataBlock(blockNumber);\r\n            \r\n            }\r\n        } catch (err) {\r\n            console.log(err.message);\r\n        }\r\n\r\n        setTimeout(this.pullEvents, 5000);\r\n    }\r\n\r\n    start = () => {\r\n        this.pullEvents();\r\n    }\r\n}\r\n\r\nexport default EventHandler;"]},"metadata":{},"sourceType":"module"}