{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport web3 from '../ethereum/web3';\nimport appDispatcher from '../core/AppDispatcher';\nimport Constant from '../support/Constant';\nimport utils from '../support/Utils'; // EventHandler object currently make requests to the smart contract periodically \n//    to get events initiated by the contract.\n\nclass EventHandler {\n  constructor(myAddress, contractManager, storageManager) {\n    _defineProperty(this, \"pullContactEvents\", async (blockNumber, currentDataBlock) => {\n      // Get list of invitation requests that the current user sent\n      var myRequestEvents = await this.contractManager.getPastEvents('addContactEvent', {\n        filter: {\n          from: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addRequestEvents(myRequestEvents); // Get list of invitation requests from other users send to the current user\n\n      var invitationEvents = await this.contractManager.getPastEvents('addContactEvent', {\n        filter: {\n          to: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addInvitationEvents(invitationEvents);\n\n      for (var i = 0; i < myRequestEvents.length; i++) {\n        await this.contractManager.getMemberInfo(myRequestEvents[i].returnValues.to, Constant.Relationship.Requested);\n      }\n\n      for (var i = 0; i < invitationEvents.length; i++) {\n        await this.contractManager.getMemberInfo(invitationEvents[i].returnValues.from, Constant.Relationship.NoRelation);\n      }\n\n      var myAcceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\n        filter: {\n          from: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addMyAcceptContactEvents(myAcceptContactEvents);\n      var acceptContactEvents = await this.contractManager.getPastEvents('acceptContactEvent', {\n        filter: {\n          to: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      this.storageManager.addAcceptContactEvents(acceptContactEvents); // If the one who accept our contact doesn't have publicKey yet \n      // we need to get it from the smart contract\n\n      for (var i = 0; i < acceptContactEvents.length; i++) {\n        var fromAddress = acceptContactEvents[i].returnValues.from;\n\n        if (!this.storageManager.contacts[fromAddress].publicKey) {\n          await this.contractManager.getMemberInfo(fromAddress, Constant.Relationship.Connected);\n        }\n      } // Get profile update event to check if anyone in the current user contact list has updated their profile\n\n\n      var profileUpdateEvents = await this.contractManager.getPastEvents('profileUpdateEvent', {\n        filter: {\n          from: this.storageManager.contactAddresses\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n\n      for (var i = 0; i < profileUpdateEvents.length; i++) {\n        var eventData = profileUpdateEvents[i].returnValues;\n        this.storageManager.updateContact(eventData.from, \"\", utils.hexStringToAsciiString(eventData.name), utils.hexStringToAsciiString(eventData.avatarUrl), 0);\n      }\n\n      if (myRequestEvents.length > 0 || invitationEvents.length > 0 || profileUpdateEvents.length > 0 || myAcceptContactEvents.length > 0 || acceptContactEvents.length > 0) {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.CONTACT_LIST_UPDATED\n        });\n      }\n    });\n\n    _defineProperty(this, \"pullMessageEvents\", async (blockNumber, currentDataBlock) => {\n      var messagesSent = await this.contractManager.getPastEvents('messageSentEvent', {\n        filter: {\n          from: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      var messagesReceived = await this.contractManager.getPastEvents('messageSentEvent', {\n        filter: {\n          to: this.myAddress\n        },\n        fromBlock: currentDataBlock + 1,\n        toBlock: blockNumber\n      });\n      var iSent = 0;\n      var iReceived = 0;\n\n      while (iSent < messagesSent.length || iReceived < messagesReceived.length) {\n        if (iSent >= messagesSent.length) {\n          this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\n          iReceived++;\n        } else if (iReceived >= messagesReceived.length) {\n          this.storageManager.addMyMessageEvent(messagesSent[iSent]);\n          iSent++;\n        } else {\n          if (messagesSent[iSent].blockNumber < messagesReceived[iReceived].blockNumber) {\n            this.storageManager.addMyMessageEvent(messagesSent[iSent]);\n            iSent++;\n          } else {\n            this.storageManager.addMessageFromFriendEvent(messagesReceived[iReceived]);\n            iReceived++;\n          }\n        }\n      }\n\n      if (messagesReceived.length > 0 || messagesSent.length > 0) {\n        appDispatcher.dispatch({\n          action: Constant.EVENT.MESSAGES_UPDATED\n        });\n      }\n    });\n\n    _defineProperty(this, \"pullEvents\", async () => {\n      try {\n        // Get the last updated block number\n        var currentDataBlock = this.storageManager.getCurrentDataBlock();\n        var blockNumber = await web3.eth.getBlockNumber();\n\n        if (blockNumber > currentDataBlock) {\n          await this.pullContactEvents(blockNumber, currentDataBlock);\n          await this.pullMessageEvents(blockNumber, currentDataBlock);\n          this.storageManager.setCurrentDataBlock(blockNumber);\n        }\n      } catch (err) {\n        console.log(err.message);\n      }\n\n      setTimeout(this.pullEvents, 5000);\n    });\n\n    _defineProperty(this, \"start\", () => {\n      this.pullEvents();\n    });\n\n    this.myAddress = myAddress;\n    this.contractManager = contractManager;\n    this.storageManager = storageManager;\n  }\n\n}\n\nexport default EventHandler;","map":null,"metadata":{},"sourceType":"module"}