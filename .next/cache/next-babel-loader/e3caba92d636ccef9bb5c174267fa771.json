{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport web3 from '../ethereum/web3';\nimport compiledContract from '../ethereum/build/EtherChat.json';\nimport TransactionsManager from './TransactionManager';\nimport appDispatcher from './AppDispatcher';\nimport Config from '../support/Config';\nimport Constant from '../support/Constant';\nimport utils from '../support/Utils'; // import crypto from 'crypto';\n\n/**\r\n * Responsible for interacting with the Ethereum smart contract\r\n */\n\nvar ContractManager = function ContractManager(accountManager, storageManager) {\n  var _this = this;\n\n  _classCallCheck(this, ContractManager);\n\n  _defineProperty(this, \"getContract\", function _callee() {\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _regeneratorRuntime.awrap(new web3.eth.Contract(JSON.parse(compiledContract[\"interface\"]), Config.ENV.ContractAddress));\n\n          case 2:\n            _this.contract = _context.sent;\n            appDispatcher.dispatch({\n              action: Constant.EVENT.CONTRACT_READY\n            });\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"getProfile\", function _callee2(address) {\n    var result, profile;\n    return _regeneratorRuntime.async(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _regeneratorRuntime.awrap(_this.contract.methods.members(_this.accountManager.getAddress()).call());\n\n          case 2:\n            result = _context2.sent;\n            profile = {};\n\n            if (result.isMember == 1) {\n              profile.isJoined = true;\n              profile.avatarUrl = utils.hexStringToAsciiString(result.avatarUrl);\n              profile.name = utils.hexStringToAsciiString(result.name);\n\n              _this.storageManager.setJoinedStatus(true);\n\n              _this.storageManager.setName(_this.name);\n\n              _this.storageManager.setAvatarUrl(_this.avatarUrl);\n\n              appDispatcher.dispatch({\n                action: Constant.EVENT.ACCOUNT_INFO_UPDATED,\n                profile: profile\n              });\n            }\n\n            return _context2.abrupt(\"return\", profile);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"getMemberInfo\", function _callee3(address, relationship) {\n    var memberInfo, publicKey, name, avatarUrl;\n    return _regeneratorRuntime.async(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return _regeneratorRuntime.awrap(_this.contract.methods.members(address).call());\n\n          case 2:\n            memberInfo = _context3.sent;\n\n            if (memberInfo.isMember) {\n              publicKey = '04' + memberInfo.publicKeyLeft.substr(2) + memberInfo.publicKeyRight.substr(2);\n              name = utils.hexStringToAsciiString(memberInfo.name);\n              avatarUrl = utils.hexStringToAsciiString(memberInfo.avatarUrl);\n\n              _this.storageManager.updateContact(address, publicKey, name, avatarUrl, relationship);\n            }\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"getPastEvents\", function _callee4(eventName, filters) {\n    return _regeneratorRuntime.async(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return _regeneratorRuntime.awrap(_this.contract.getPastEvents(eventName, filters));\n\n          case 2:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"joinContract\", function _callee5(publicKeyBuffer, callback) {\n    var publicKeyLeft, publicKeyRight;\n    return _regeneratorRuntime.async(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            publicKeyLeft = '0x' + publicKeyBuffer.toString('hex', 0, 32);\n            publicKeyRight = '0x' + publicKeyBuffer.toString('hex', 32, 64);\n\n            _this.transactionManager.executeMethod(_this.contract.methods.join(publicKeyLeft, publicKeyRight)).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n              if (callback) callback(Constant.EVENT.ON_APPROVED);\n            }).on(Constant.EVENT.ON_REJECTED, function (txHash) {\n              if (callback) callback(Constant.EVENT.ON_REJECTED);\n            }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n              if (callback) callback(Constant.EVENT.ON_RECEIPT);\n            }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n              appDispatcher.dispatch({\n                action: Constant.EVENT.ENCOUNTERED_ERROR,\n                message: error.message,\n                title: \"Error\"\n              });\n              if (callback) callback(Constant.EVENT.ON_ERROR);\n            });\n\n          case 3:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"addContact\", function _callee6(address, callback) {\n    var method;\n    return _regeneratorRuntime.async(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            console.log(address);\n            method = _this.contract.methods.addContact(address);\n\n            _this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n              if (callback) callback(Constant.EVENT.ON_APPROVED);\n            }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n              if (callback) callback(Constant.EVENT.ON_RECEIPT);\n            }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n              appDispatcher.dispatch({\n                action: Constant.EVENT.ENCOUNTERED_ERROR,\n                message: error.message,\n                title: \"Error\"\n              });\n              if (callback) callback(Constant.EVENT.ON_ERROR);\n            });\n\n          case 3:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"acceptContactRequest\", function _callee7(address, callback) {\n    var method;\n    return _regeneratorRuntime.async(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            method = _this.contract.methods.acceptContactRequest(address);\n\n            _this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n              if (callback) callback(Constant.EVENT.ON_APPROVED);\n            }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n              if (callback) callback(Constant.EVENT.ON_RECEIPT);\n            }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n              appDispatcher.dispatch({\n                action: Constant.EVENT.ENCOUNTERED_ERROR,\n                message: error.message,\n                title: \"Error\"\n              });\n              if (callback) callback(Constant.EVENT.ON_ERROR);\n            });\n\n          case 2:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"updateProfile\", function _callee8(name, avatarUrl, callback) {\n    var nameHex, avatarUrlHex, method;\n    return _regeneratorRuntime.async(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            nameHex = '0x' + Buffer.from(name, 'ascii').toString('hex');\n            avatarUrlHex = '0x' + Buffer.from(avatarUrl, 'ascii').toString('hex');\n            method = _this.contract.methods.updateProfile(nameHex, avatarUrlHex);\n\n            _this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n              if (callback) callback(Constant.EVENT.ON_APPROVED);\n            }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n              if (callback) callback(Constant.EVENT.ON_RECEIPT);\n            }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n              appDispatcher.dispatch({\n                action: Constant.EVENT.ENCOUNTERED_ERROR,\n                message: error.message,\n                title: \"Error\"\n              });\n              if (callback) callback(Constant.EVENT.ON_ERROR);\n            });\n\n          case 4:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    });\n  });\n\n  _defineProperty(this, \"sendMessage\", function _callee9(toAddress, publicKey, message) {\n    var publicKeyBuffer, encryptedRaw, encryptedMessage, method;\n    return _regeneratorRuntime.async(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            publicKeyBuffer = Buffer.from(publicKey, 'hex');\n            encryptedRaw = utils.encrypt(message, _this.accountManager.computeSecret(publicKeyBuffer));\n            encryptedMessage = '0x' + encryptedRaw.toString('hex');\n            method = _this.contract.methods.sendMessage(toAddress, encryptedMessage, utils.getEncryptAlgorithmInHex());\n\n            _this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, function (txHash) {\n              _this.storageManager.addMyLocalMessage(encryptedMessage, toAddress, utils.getEncryptAlgorithm(), txHash);\n\n              appDispatcher.dispatch({\n                action: Constant.EVENT.MESSAGES_UPDATED,\n                data: toAddress\n              });\n            }).on(Constant.EVENT.ON_REJECTED, function (data) {// do nothing\n            }).on(Constant.EVENT.ON_RECEIPT, function (receipt) {\n              _this.storageManager.updateLocalMessage(toAddress, receipt.transactionHash, Constant.SENT_STATUS.SUCCESS);\n\n              appDispatcher.dispatch({\n                action: Constant.EVENT.MESSAGES_UPDATED,\n                data: toAddress\n              });\n            }).on(Constant.EVENT.ON_ERROR, function (error, txHash) {\n              _this.storageManager.updateLocalMessage(toAddress, txHash, Constant.SENT_STATUS.FAILED);\n\n              appDispatcher.dispatch({\n                action: Constant.EVENT.MESSAGES_UPDATED,\n                data: toAddress\n              });\n            });\n\n          case 5:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    });\n  });\n\n  this.getContract();\n  this.accountManager = accountManager;\n  this.storageManager = storageManager;\n  this.transactionManager = new TransactionsManager(accountManager);\n} // Create a web3 contract object that represent the ethereum smart contract\n;\n\nexport default ContractManager;","map":null,"metadata":{},"sourceType":"module"}