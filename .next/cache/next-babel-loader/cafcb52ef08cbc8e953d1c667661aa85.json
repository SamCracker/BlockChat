{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport web3 from '../ethereum/web3';\nimport compiledContract from '../ethereum/build/EtherChat.json';\nimport TransactionsManager from './TransactionManager';\nimport appDispatcher from './AppDispatcher';\nimport Config from '../support/Config';\nimport Constant from '../support/Constant';\nimport utils from '../support/Utils'; // import crypto from 'crypto';\n\n/**\r\n * Responsible for interacting with the Ethereum smart contract\r\n */\n\nclass ContractManager {\n  constructor(accountManager, storageManager) {\n    _defineProperty(this, \"getContract\", async () => {\n      this.contract = await new web3.eth.Contract(JSON.parse(compiledContract.interface), Config.ENV.ContractAddress);\n      appDispatcher.dispatch({\n        action: Constant.EVENT.CONTRACT_READY\n      });\n    });\n\n    _defineProperty(this, \"getProfile\", async address => {\n      var result = await this.contract.methods.members(this.accountManager.getAddress()).call();\n      var profile = {};\n\n      if (result.isMember == 1) {\n        profile.isJoined = true;\n        profile.avatarUrl = utils.hexStringToAsciiString(result.avatarUrl);\n        profile.name = utils.hexStringToAsciiString(result.name);\n        this.storageManager.setJoinedStatus(true);\n        this.storageManager.setName(this.name);\n        this.storageManager.setAvatarUrl(this.avatarUrl);\n        appDispatcher.dispatch({\n          action: Constant.EVENT.ACCOUNT_INFO_UPDATED,\n          profile: profile\n        });\n      }\n\n      return profile;\n    });\n\n    _defineProperty(this, \"getMemberInfo\", async (address, relationship) => {\n      var memberInfo = await this.contract.methods.members(address).call();\n\n      if (memberInfo.isMember) {\n        var publicKey = '04' + memberInfo.publicKeyLeft.substr(2) + memberInfo.publicKeyRight.substr(2);\n        var name = utils.hexStringToAsciiString(memberInfo.name);\n        var avatarUrl = utils.hexStringToAsciiString(memberInfo.avatarUrl);\n        this.storageManager.updateContact(address, publicKey, name, avatarUrl, relationship);\n      }\n    });\n\n    _defineProperty(this, \"getPastEvents\", async (eventName, filters) => {\n      return await this.contract.getPastEvents(eventName, filters);\n    });\n\n    this.getContract();\n    this.accountManager = accountManager;\n    this.storageManager = storageManager;\n    this.transactionManager = new TransactionsManager(accountManager);\n  } // Create a web3 contract object that represent the ethereum smart contract\n\n\n  async joinContract(publicKeyBuffer, callback) {\n    var publicKeyLeft = '0x' + publicKeyBuffer.toString('hex', 0, 32);\n    var publicKeyRight = '0x' + publicKeyBuffer.toString('hex', 32, 64);\n    this.transactionManager.executeMethod(this.contract.methods.join(publicKeyLeft, publicKeyRight)).on(Constant.EVENT.ON_APPROVED, txHash => {\n      if (callback) callback(Constant.EVENT.ON_APPROVED);\n    }).on(Constant.EVENT.ON_REJECTED, txHash => {\n      if (callback) callback(Constant.EVENT.ON_REJECTED);\n    }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n      if (callback) callback(Constant.EVENT.ON_RECEIPT);\n    }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n      appDispatcher.dispatch({\n        action: Constant.EVENT.ENCOUNTERED_ERROR,\n        message: error.message,\n        title: \"Error\"\n      });\n      if (callback) callback(Constant.EVENT.ON_ERROR);\n    });\n  }\n\n}\n\njoinContract = async (publicKeyBuffer, callback) => {\n  addContact = async (address, callback) => {\n    console.log(address);\n    var method = this.contract.methods.addContact(address);\n    this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n      if (callback) callback(Constant.EVENT.ON_APPROVED);\n    }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n      if (callback) callback(Constant.EVENT.ON_RECEIPT);\n    }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n      appDispatcher.dispatch({\n        action: Constant.EVENT.ENCOUNTERED_ERROR,\n        message: error.message,\n        title: \"Error\"\n      });\n      if (callback) callback(Constant.EVENT.ON_ERROR);\n    });\n  };\n\n  acceptContactRequest = async (address, callback) => {\n    var method = this.contract.methods.acceptContactRequest(address);\n    this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n      if (callback) callback(Constant.EVENT.ON_APPROVED);\n    }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n      if (callback) callback(Constant.EVENT.ON_RECEIPT);\n    }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n      appDispatcher.dispatch({\n        action: Constant.EVENT.ENCOUNTERED_ERROR,\n        message: error.message,\n        title: \"Error\"\n      });\n      if (callback) callback(Constant.EVENT.ON_ERROR);\n    });\n  };\n\n  updateProfile = async (name, avatarUrl, callback) => {\n    var nameHex = '0x' + Buffer.from(name, 'ascii').toString('hex');\n    var avatarUrlHex = '0x' + Buffer.from(avatarUrl, 'ascii').toString('hex');\n    var method = this.contract.methods.updateProfile(nameHex, avatarUrlHex);\n    this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n      if (callback) callback(Constant.EVENT.ON_APPROVED);\n    }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n      if (callback) callback(Constant.EVENT.ON_RECEIPT);\n    }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n      appDispatcher.dispatch({\n        action: Constant.EVENT.ENCOUNTERED_ERROR,\n        message: error.message,\n        title: \"Error\"\n      });\n      if (callback) callback(Constant.EVENT.ON_ERROR);\n    });\n  }; // A message will be encrypted locally before sending to the smart contract\n\n\n  sendMessage = async (toAddress, publicKey, message) => {\n    var publicKeyBuffer = Buffer.from(publicKey, 'hex');\n    var encryptedRaw = utils.encrypt(message, this.accountManager.computeSecret(publicKeyBuffer));\n    var encryptedMessage = '0x' + encryptedRaw.toString('hex');\n    var method = this.contract.methods.sendMessage(toAddress, encryptedMessage, utils.getEncryptAlgorithmInHex());\n    this.transactionManager.executeMethod(method).on(Constant.EVENT.ON_APPROVED, txHash => {\n      this.storageManager.addMyLocalMessage(encryptedMessage, toAddress, utils.getEncryptAlgorithm(), txHash);\n      appDispatcher.dispatch({\n        action: Constant.EVENT.MESSAGES_UPDATED,\n        data: toAddress\n      });\n    }).on(Constant.EVENT.ON_REJECTED, data => {// do nothing\n    }).on(Constant.EVENT.ON_RECEIPT, receipt => {\n      this.storageManager.updateLocalMessage(toAddress, receipt.transactionHash, Constant.SENT_STATUS.SUCCESS);\n      appDispatcher.dispatch({\n        action: Constant.EVENT.MESSAGES_UPDATED,\n        data: toAddress\n      });\n    }).on(Constant.EVENT.ON_ERROR, (error, txHash) => {\n      this.storageManager.updateLocalMessage(toAddress, txHash, Constant.SENT_STATUS.FAILED);\n      appDispatcher.dispatch({\n        action: Constant.EVENT.MESSAGES_UPDATED,\n        data: toAddress\n      });\n    });\n  };\n};\n\nexport default ContractManager;","map":{"version":3,"sources":["D:/BlockChat/BlockChat/core/ContractManager.js"],"names":["web3","compiledContract","TransactionsManager","appDispatcher","Config","Constant","utils","ContractManager","constructor","accountManager","storageManager","contract","eth","Contract","JSON","parse","interface","ENV","ContractAddress","dispatch","action","EVENT","CONTRACT_READY","address","result","methods","members","getAddress","call","profile","isMember","isJoined","avatarUrl","hexStringToAsciiString","name","setJoinedStatus","setName","setAvatarUrl","ACCOUNT_INFO_UPDATED","relationship","memberInfo","publicKey","publicKeyLeft","substr","publicKeyRight","updateContact","eventName","filters","getPastEvents","getContract","transactionManager","joinContract","publicKeyBuffer","callback","toString","executeMethod","join","on","ON_APPROVED","txHash","ON_REJECTED","ON_RECEIPT","receipt","ON_ERROR","error","ENCOUNTERED_ERROR","message","title","addContact","console","log","method","acceptContactRequest","updateProfile","nameHex","Buffer","from","avatarUrlHex","sendMessage","toAddress","encryptedRaw","encrypt","computeSecret","encryptedMessage","getEncryptAlgorithmInHex","addMyLocalMessage","getEncryptAlgorithm","MESSAGES_UPDATED","data","updateLocalMessage","transactionHash","SENT_STATUS","SUCCESS","FAILED"],"mappings":"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","sourcesContent":["import web3 from '../ethereum/web3';\r\nimport compiledContract from '../ethereum/build/EtherChat.json';\r\nimport TransactionsManager from './TransactionManager';\r\nimport appDispatcher from './AppDispatcher';\r\nimport Config from '../support/Config';\r\nimport Constant from '../support/Constant';\r\nimport utils from '../support/Utils';\r\n// import crypto from 'crypto';\r\n\r\n/**\r\n * Responsible for interacting with the Ethereum smart contract\r\n */\r\n\r\nclass ContractManager {\r\n    constructor(accountManager, storageManager) {\r\n        this.getContract();\r\n        this.accountManager = accountManager;\r\n        this.storageManager = storageManager;\r\n        this.transactionManager = new TransactionsManager(accountManager);\r\n    }\r\n\r\n    // Create a web3 contract object that represent the ethereum smart contract\r\n    getContract = async () => {\r\n        this.contract = await new web3.eth.Contract(JSON.parse(compiledContract.interface), \r\n                Config.ENV.ContractAddress);\r\n        appDispatcher.dispatch({\r\n            action: Constant.EVENT.CONTRACT_READY\r\n        })\r\n    }\r\n\r\n    // Get current account profile from EtherChat contract's storage\r\n    getProfile = async (address) => {\r\n        var result = await this.contract.methods.members(this.accountManager.getAddress()).call();\r\n        var profile = {};\r\n        if (result.isMember == 1) {\r\n            profile.isJoined = true;\r\n            profile.avatarUrl = utils.hexStringToAsciiString(result.avatarUrl);\r\n            profile.name = utils.hexStringToAsciiString(result.name);\r\n\r\n            this.storageManager.setJoinedStatus(true);\r\n            this.storageManager.setName(this.name);\r\n            this.storageManager.setAvatarUrl(this.avatarUrl);\r\n            \r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.ACCOUNT_INFO_UPDATED,\r\n                profile: profile\r\n            })\r\n        }\r\n        return profile;\r\n    }\r\n\r\n    getMemberInfo = async (address, relationship) => {\r\n        var memberInfo = await this.contract.methods.members(address).call();\r\n        if (memberInfo.isMember) {\r\n            var publicKey = '04' + memberInfo.publicKeyLeft.substr(2) + memberInfo.publicKeyRight.substr(2);\r\n            var name = utils.hexStringToAsciiString(memberInfo.name);\r\n            var avatarUrl = utils.hexStringToAsciiString(memberInfo.avatarUrl);\r\n            this.storageManager.updateContact(address, publicKey, name, avatarUrl, relationship);\r\n        }\r\n    }\r\n\r\n    getPastEvents = async (eventName, filters) => {\r\n        return await this.contract.getPastEvents(eventName, filters);\r\n    }\r\n\r\n    async joinContract(publicKeyBuffer, callback) {\r\n        var publicKeyLeft = '0x' + publicKeyBuffer.toString('hex', 0, 32);\r\n    var publicKeyRight = '0x' + publicKeyBuffer.toString('hex', 32, 64);\r\n\r\n    this.transactionManager.executeMethod(this.contract.methods.join(publicKeyLeft, publicKeyRight))\r\n        .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n            if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n        })\r\n        .on(Constant.EVENT.ON_REJECTED, (txHash) => {\r\n            if (callback) callback(Constant.EVENT.ON_REJECTED);\r\n        })\r\n        .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n            if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n        })\r\n        .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n            appDispatcher.dispatch({\r\n                action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                message: error.message,\r\n                title: \"Error\"\r\n            });\r\n            if (callback) callback(Constant.EVENT.ON_ERROR);\r\n        });\r\n    }\r\n    \r\n}\r\n    joinContract = async (publicKeyBuffer, callback) => {\r\n\r\n    addContact = async (address, callback) => {\r\n        console.log(address);\r\n\r\n        var method = this.contract.methods.addContact(address);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    acceptContactRequest = async (address, callback) => {\r\n        var method = this.contract.methods.acceptContactRequest(address);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    updateProfile = async (name, avatarUrl, callback) => {\r\n        var nameHex = '0x' + Buffer.from(name, 'ascii').toString('hex');\r\n        var avatarUrlHex = '0x' + Buffer.from(avatarUrl, 'ascii').toString('hex');\r\n        var method = this.contract.methods.updateProfile(nameHex, avatarUrlHex);\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                if (callback) callback(Constant.EVENT.ON_APPROVED);\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt) => {\r\n                if (callback) callback(Constant.EVENT.ON_RECEIPT);\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.ENCOUNTERED_ERROR,\r\n                    message: error.message,\r\n                    title: \"Error\"\r\n                });\r\n                if (callback) callback(Constant.EVENT.ON_ERROR);\r\n            });\r\n    }\r\n\r\n    // A message will be encrypted locally before sending to the smart contract\r\n    sendMessage = async (toAddress, publicKey, message) => {\r\n        var publicKeyBuffer = Buffer.from(publicKey, 'hex');\r\n        var encryptedRaw = utils.encrypt(message, this.accountManager.computeSecret(publicKeyBuffer));\r\n        var encryptedMessage = '0x' + encryptedRaw.toString('hex');\r\n        var method = this.contract.methods.sendMessage(toAddress, encryptedMessage, utils.getEncryptAlgorithmInHex());\r\n\r\n        this.transactionManager.executeMethod(method)\r\n            .on(Constant.EVENT.ON_APPROVED, (txHash) => {\r\n                this.storageManager.addMyLocalMessage(encryptedMessage, toAddress, utils.getEncryptAlgorithm(), txHash);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            })\r\n            .on(Constant.EVENT.ON_REJECTED, (data) => {\r\n                // do nothing\r\n            })\r\n            .on(Constant.EVENT.ON_RECEIPT, (receipt, ) => {\r\n                this.storageManager.updateLocalMessage(toAddress, receipt.transactionHash, Constant.SENT_STATUS.SUCCESS);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            })\r\n            .on(Constant.EVENT.ON_ERROR, (error, txHash) => {\r\n                this.storageManager.updateLocalMessage(toAddress, txHash, Constant.SENT_STATUS.FAILED);\r\n                appDispatcher.dispatch({\r\n                    action: Constant.EVENT.MESSAGES_UPDATED,\r\n                    data: toAddress\r\n                });\r\n            });\r\n    }\r\n}\r\n\r\nexport default ContractManager;"]},"metadata":{},"sourceType":"module"}